/// <reference types="vitest/globals" />

import type { Job, Queue } from 'bullmq';

import { afterEach, beforeEach, describe, expect, it, Mock, vi } from 'vitest';

// Mock external dependencies
vi.mock('./modules/redis/redisClient', async () => {
  const mockRedisClient = {
    del: vi.fn(),
    duplicate: vi.fn(() => mockRedisClient),
    get: vi.fn(),
    incr: vi.fn(),
    lrange: vi.fn().mockResolvedValue([]),
    on: vi.fn(),
    options: { host: 'localhost', port: 6379 },
    publish: vi.fn(),
    quit: vi.fn(),
    rpush: vi.fn(),
    set: vi.fn(),
    subscribe: vi.fn(),
    unsubscribe: vi.fn(),
  } as any;
  return {
    getRedisClientInstance: vi.fn(() => mockRedisClient),
  };
});



vi.mock('pg', () => ({
  Client: vi.fn(() => ({
    connect: vi.fn().mockResolvedValue(undefined),
    end: vi.fn().mockResolvedValue(undefined),
    on: vi.fn(), // Add the missing 'on' method
    query: vi.fn().mockResolvedValue({ rows: [] }),
  })),
}));

vi.mock('./config', async (importOriginal) => {
  const actual = await importOriginal<typeof import('./config')>();
  const mockedConfig = {
    HISTORY_MAX_LENGTH: 10,
    LLM_PROVIDER: 'gemini',
    REDIS_HOST: 'localhost',
    REDIS_PORT: 6379,
  };
  return {
    ...actual,
    config: mockedConfig,
    getConfig: vi.fn(() => mockedConfig),
  };
});

vi.mock('./logger', () => {
  const mockChildLogger = {
    debug: vi.fn(),
    error: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
  };
  const mockLogger = {
    child: vi.fn(() => mockChildLogger),
    debug: vi.fn(),
    error: vi.fn(),
    info: vi.fn(),
    warn: vi.fn(),
  };
  return {
    _mockChildLogger: mockChildLogger, // Export for direct access in tests
    getLogger: vi.fn(() => mockLogger),
    getLoggerInstance: vi.fn(() => mockLogger),
  };
});

vi.mock('./modules/agent/agent');
const _mockSessionManagerInstance = {
  getSession: vi.fn(),
  saveSession: vi.fn(),
};
vi.mock('./modules/session/sessionManager', () => ({
  SessionManager: vi.fn(() => _mockSessionManagerInstance),
}));

vi.mock('./modules/tools/definitions/ai/summarize.tool', () => ({
  summarizeTool: {
    execute: vi.fn(),
  },
}));

import { getConfig as _getConfig, config } from './config';
import { getLoggerInstance } from './logger';
import { Agent } from './modules/agent/agent';
import * as _redis from './modules/redis/redisClient';
import { getRedisClientInstance } from './modules/redis/redisClient';
import { SessionManager as _SessionManager } from './modules/session/sessionManager';
import { summarizeTool } from './modules/tools/definitions/ai/summarize.tool';
import { AppError as _AppError } from './utils/errorUtils';
import { processJob } from './worker';

describe('processJob', () => {
  let mockJob: Partial<Job>;
  let mockTools: any[];
  let mockSessionData: any;
  let mockJobQueue: Queue;
  let mockRedisConnection: any;

  beforeEach(() => {
    mockJob = {
      data: {
        llmApiKey: 'testApiKey',
        llmModelName: 'testModelName',
        sessionId: 'testSessionId',
      },
      id: 'testJobId',
      name: 'testJob',
    };
    // Initialize with empty array, but note that actual implementation loads all tools
    mockTools = [];
    mockSessionData = {
      history: [],
    };
    mockJobQueue = {
      add: vi.fn(),
    } as any;
    mockRedisConnection = getRedisClientInstance();

    // Mock config.HISTORY_MAX_LENGTH for testing purposes
    config.HISTORY_MAX_LENGTH = 10;

    vi.resetAllMocks();
    _mockSessionManagerInstance.getSession.mockResolvedValue(mockSessionData);
    (Agent as Mock).mockImplementation(() => ({
      run: vi.fn().mockResolvedValue('Agent final response'),
    }));
    (summarizeTool.execute as any).mockResolvedValue('Summarized conversation');
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  afterAll(() => {
    const redisClient = getRedisClientInstance();
    if (redisClient && typeof redisClient.quit === 'function') {
      redisClient.quit();
    }
  });

  it('should handle AppError and publish an error event', async () => {
    const errorMessage = 'This is an application error';
    (Agent as any).mockImplementation(() => ({
      run: vi.fn().mockRejectedValue(new _AppError(errorMessage)),
    }));

    await expect(
      processJob(
        mockJob as Job,
        mockJobQueue,
        _mockSessionManagerInstance as any,
        mockRedisConnection,
      ),
    ).rejects.toThrow(_AppError);

    expect(getLoggerInstance().child).toHaveBeenCalledWith({
      jobId: 'testJobId',
      sessionId: 'testSessionId',
    });
    const childLogger = (getLoggerInstance().child as Mock).mock.results[0]
      .value;
    expect(childLogger.error).toHaveBeenCalledWith(
      expect.any(Object),
      `Erreur dans l'exécution de l'agent`,
    );
    await expect(mockRedisConnection.publish).toHaveBeenCalledWith(
      'job:testJobId:events',
      JSON.stringify({ message: errorMessage, type: 'error' }),
    );
    await expect(mockRedisConnection.publish).toHaveBeenCalledWith(
      'job:testJobId:events',
      JSON.stringify({ content: 'Stream terminé.', type: 'close' }),
    );
    // Explicitly assert that saveSession is NOT called in the error path
    expect(_mockSessionManagerInstance.saveSession).not.toHaveBeenCalled();
  }, 30000);

  it('should process a job successfully and return the final response', async () => {
    mockSessionData.history = Array(10).fill({
      content: 'old message',
      role: 'user',
    }); // Ensure history exceeds max length after adding one more message
    const result = await processJob(
      mockJob as Job,
      mockJobQueue,
      _mockSessionManagerInstance as any,
      mockRedisConnection,
    );

    expect(_mockSessionManagerInstance.getSession).toHaveBeenCalledWith(
      'testSessionId',
    );
    // Note: We're not checking the exact tools array since it's loaded dynamically
    expect(Agent).toHaveBeenCalled();
    expect((Agent as Mock).mock.calls[0][0]).toEqual(mockJob);
    expect((Agent as Mock).mock.calls[0][1]).toEqual(mockSessionData);
    expect((Agent as Mock).mock.calls[0][2]).toEqual(mockJobQueue);
    expect((Agent as Mock).mock.calls[0][4]).toEqual('gemini');
    expect((Agent as Mock).mock.calls[0][5]).toEqual(
      _mockSessionManagerInstance,
    );
    expect((Agent as Mock).mock.calls[0][6]).toEqual(mockJob.data.llmApiKey);
    expect((Agent as Mock).mock.calls[0][7]).toEqual(mockJob.data.llmModelName);

    expect(result).toBe('Agent final response');
    expect(_mockSessionManagerInstance.saveSession).toHaveBeenCalled();
  }, 30000);
});
