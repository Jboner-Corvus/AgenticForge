import { useCallback, useEffect, useState } from 'react';

import { useLanguage } from '../lib/contexts/LanguageContext';
import { clientConfig } from '../config';
import { testServerHealth } from '../lib/api';
import { useCombinedStore as useStore } from '../store';
import { useLLMKeysStore } from '../store/llmKeysStore';

function generateUUID() {
  return `${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
}

export const AppInitializer = () => {
  const { translations } = useLanguage();
  const addDebugLog = useStore((state) => state.addDebugLog);
  const addMessage = useStore((state) => state.addMessage);
  const setAuthToken = useStore((state) => state.setAuthToken);
  const setServerHealthy = useStore((state) => state.setServerHealthy);
  const setSessionId = useStore((state) => state.setSessionId);
  const setTokenStatus = useStore((state) => state.setTokenStatus);
  const fetchAndDisplayToolCount = useStore((state) => state.fetchAndDisplayToolCount);
  
  // LLM Keys store
  const fetchKeys = useLLMKeysStore((state) => state.fetchKeys);
  
  // Add detailed error state management
  const [initError, setInitError] = useState<string | null>(null);
  const [initStage, setInitStage] = useState<string>('starting');
  const [debugInfo, setDebugInfo] = useState<Record<string, unknown>>({});

  const initializeSession = useCallback(() => {
    let currentSessionId = localStorage.getItem('agenticForgeSessionId');
    if (!currentSessionId) {
      currentSessionId = generateUUID();
      localStorage.setItem('agenticForgeSessionId', currentSessionId);
      addDebugLog(`[${new Date().toLocaleTimeString()}] [INFO] ${translations.newSessionGenerated}: ${currentSessionId}`);
    } else {
      addDebugLog(`[${new Date().toLocaleTimeString()}] [INFO] ${translations.sessionRetrieved}: ${currentSessionId}`);
    }
    setSessionId(currentSessionId);
  }, [addDebugLog, setSessionId, translations]);

  const checkServerHealth = useCallback(async () => {
    setInitStage('server_health_check');
    addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üè• === D√âBUT V√âRIFICATION SERVEUR ===`);
    addDebugLog(`[${new Date().toLocaleTimeString()}] [INFO] ${translations.checkingServerHealth}`);
    
    try {
      const startTime = Date.now();
      const healthy = await testServerHealth();
      const duration = Date.now() - startTime;
      
      setServerHealthy(healthy);
      setDebugInfo(prev => ({ ...prev, serverHealth: { healthy, duration, timestamp: Date.now() } }));
      
      addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üè• R√©ponse serveur re√ßue en ${duration}ms`);
      addDebugLog(`[${new Date().toLocaleTimeString()}] [${healthy ? 'SUCCESS' : 'ERROR'}] ${translations.serverStatus}: ${healthy ? translations.serverOnline : translations.serverOffline}`);
      
      if (healthy) {
        setInitStage('server_health_success');
      } else {
        setInitStage('server_health_failed');
        setInitError('Serveur non accessible');
        addMessage({
          type: 'error',
          content: `üè• ERREUR SERVEUR\n\n‚ùå Le serveur backend n'est pas accessible.\n\nüîç Diagnostic:\n- Temps de r√©ponse: ${duration}ms\n- Status: ${healthy ? 'En ligne' : 'Hors ligne'}\n\nüí° Solution: V√©rifiez que le serveur backend fonctionne sur le port 8080.`
        });
      }
      
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : String(err);
      setServerHealthy(false);
      setInitError(`Erreur de connexion serveur: ${message}`);
      setInitStage('server_health_error');
      
      addDebugLog(`[${new Date().toLocaleTimeString()}] [ERROR] ${translations.serverHealthCheckFailed}: ${message}`);
      addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üö® D√©tails erreur serveur: ${JSON.stringify(err)}`);
      
      addMessage({
        type: 'error',
        content: `üö® ERREUR DE CONNEXION SERVEUR\n\n‚ùå ${message}\n\nüîç Diagnostic:\n- Type d'erreur: ${err instanceof Error ? err.constructor.name : typeof err}\n- URL test√©e: Probablement http://localhost:8080/health\n\nüí° Solutions:\n1. V√©rifiez que le serveur backend est d√©marr√©\n2. V√©rifiez la configuration CORS\n3. V√©rifiez les logs du serveur`
      });
    }
    
    addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üè• === FIN V√âRIFICATION SERVEUR ===`);
  }, [addDebugLog, setServerHealthy, translations.checkingServerHealth, translations.serverOffline, translations.serverOnline, translations.serverStatus, translations.serverHealthCheckFailed, addMessage]);

  const initializeAuthToken = useCallback(() => {
    setInitStage('auth_token_init');
    addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üîê === D√âBUT INITIALISATION TOKEN ===`);
    
    try {
      // Check if we already have a token from persisted store
      const currentToken = useStore.getState().authToken;
      addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üîç Token actuel du store: ${currentToken ? 'PR√âSENT (' + currentToken.substring(0, 20) + '...)' : 'ABSENT'}`);
      
      if (currentToken) {
        addDebugLog(`[${new Date().toLocaleTimeString()}] [INFO] ${translations.tokenLoadedFromCookie}.`);
        setTokenStatus(true);
        fetchAndDisplayToolCount();
        setInitStage('auth_token_success');
        return;
      }

      // Detailed environment variable logging
      const envDebugInfo = {
        'import.meta.env.VITE_AUTH_TOKEN': import.meta.env.VITE_AUTH_TOKEN,
        'clientConfig.VITE_AUTH_TOKEN': clientConfig.VITE_AUTH_TOKEN,
        'clientConfig.AUTH_TOKEN': clientConfig.AUTH_TOKEN,
        'import.meta.env (keys)': Object.keys(import.meta.env),
        'document.location.href': document.location.href,
        'document.location.origin': document.location.origin
      };
      
      setDebugInfo(prev => ({ ...prev, envInfo: envDebugInfo }));
      
      addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üåç Variables d'environnement:`);
      addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üìã VITE_AUTH_TOKEN (import.meta): ${import.meta.env.VITE_AUTH_TOKEN ? 'PR√âSENT (' + String(import.meta.env.VITE_AUTH_TOKEN).substring(0, 20) + '...)' : 'ABSENT'}`);
      addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üìã VITE_AUTH_TOKEN (config): ${clientConfig.VITE_AUTH_TOKEN ? 'PR√âSENT (' + clientConfig.VITE_AUTH_TOKEN.substring(0, 20) + '...)' : 'ABSENT'}`);
      addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üìã AUTH_TOKEN (config): ${clientConfig.AUTH_TOKEN ? 'PR√âSENT (' + clientConfig.AUTH_TOKEN.substring(0, 20) + '...)' : 'ABSENT'}`);
      addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üìã Cl√©s import.meta.env: ${Object.keys(import.meta.env).join(', ')}`);
      addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üåê URL actuelle: ${document.location.href}`);
      
      console.log('üîç [VERBOSE DEBUG] Environment variables:', envDebugInfo);

      const viteAuthToken = clientConfig.VITE_AUTH_TOKEN || clientConfig.AUTH_TOKEN;
      addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üéØ Token final s√©lectionn√©: ${viteAuthToken ? 'PR√âSENT (' + viteAuthToken.substring(0, 20) + '...)' : 'ABSENT'}`);

      if (viteAuthToken) {
        setAuthToken(viteAuthToken);
        addDebugLog(`[${new Date().toLocaleTimeString()}] [SUCCESS] ‚úÖ ${translations.tokenLoadedFromEnv}.`);
        setTokenStatus(true);
        fetchAndDisplayToolCount();
        setInitStage('auth_token_success');
      } else {
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üç™ Recherche dans les cookies...`);
        
        // Try to get JWT from cookie as fallback
        const cookieName = 'agenticforge_jwt=';
        const decodedCookie = decodeURIComponent(document.cookie);
        const ca = decodedCookie.split(';');
        let jwtToken = null;
        
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üç™ Cookies disponibles: ${decodedCookie ? decodedCookie.substring(0, 100) + '...' : 'AUCUN'}`);
        
        for(let i = 0; i < ca.length; i++) {
          let c = ca[i];
          while (c.charAt(0) === ' ') {
            c = c.substring(1);
          }
          if (c.indexOf(cookieName) === 0) {
            jwtToken = c.substring(cookieName.length, c.length);
            break;
          }
        }
        
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üç™ Token trouv√© dans cookies: ${jwtToken ? 'OUI (' + jwtToken.substring(0, 20) + '...)' : 'NON'}`);
        
        // Try to get token from localStorage as another fallback
        if (!jwtToken) {
          jwtToken = localStorage.getItem('authToken');
          addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üíæ Token trouv√© dans localStorage: ${jwtToken ? 'OUI (' + jwtToken.substring(0, 20) + '...)' : 'NON'}`);
        }
        
        if (jwtToken) {
          setAuthToken(jwtToken);
          addDebugLog(`[${new Date().toLocaleTimeString()}] [SUCCESS] ‚úÖ ${translations.tokenLoadedFromCookie}.`);
          setTokenStatus(true);
          fetchAndDisplayToolCount();
          setInitStage('auth_token_success');
        } else {
          // No token found - user needs to authenticate via OAuth page
          addDebugLog(`[${new Date().toLocaleTimeString()}] [INFO] ‚ÑπÔ∏è Aucun token trouv√©. L'utilisateur doit s'authentifier via la page OAuth.`);
          setTokenStatus(false);
          setInitStage('auth_token_needed');
        }
      }
      
      addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üîê === FIN INITIALISATION TOKEN ===`);
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      setInitError(`Erreur lors de l'initialisation du token: ${errorMessage}`);
      setInitStage('auth_token_error');
      addDebugLog(`[${new Date().toLocaleTimeString()}] [ERROR] üö® ERREUR TOKEN: ${errorMessage}`);
      
      addMessage({
        type: 'error',
        content: `üö® ERREUR CRITIQUE D'INITIALISATION\n\n‚ùå ${errorMessage}\n\nüîç √âtape: Initialisation du token d'authentification\n\nüí° Veuillez recharger la page ou contacter le support.`
      });
    }
  }, [addDebugLog, setAuthToken, setTokenStatus, fetchAndDisplayToolCount, translations, addMessage]);

  useEffect(() => {
    let mounted = true;
    
    const initialize = async () => {
      if (!mounted) return;
      
      try {
        setInitStage('starting');
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üöÄ === D√âBUT INITIALISATION COMPL√àTE ===`);
        addDebugLog(`[${new Date().toLocaleTimeString()}] [INFO] ${translations.interfaceInitialized}.`);
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üåê URL de la page: ${window.location.href}`);
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üì± User Agent: ${navigator.userAgent}`);
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üï∞Ô∏è Timestamp: ${new Date().toISOString()}`);
        
        // Step 1: Initialize session
        setInitStage('session_init');
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üìã √âtape 1/5: Initialisation de la session`);
        initializeSession();
        
        // Step 2: Initialize auth token
        setInitStage('auth_init');
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üîê √âtape 2/5: Initialisation du token`);
        initializeAuthToken();
        
        // Step 3: Check server health
        setInitStage('server_check');
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üè• √âtape 3/5: V√©rification du serveur`);
        await checkServerHealth();
        
        if (!mounted) return;
        
        // Step 4: Initialize messages
        setInitStage('messages_init');
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üí¨ √âtape 4/6: Initialisation des messages`);
        await useStore.getState().initializeSessionAndMessages();
        
        // Step 5: Fetch LLM Keys
        setInitStage('llm_keys_init');
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üîë √âtape 5/6: R√©cup√©ration des cl√©s LLM`);
        try {
          await fetchKeys();
          addDebugLog(`[${new Date().toLocaleTimeString()}] [SUCCESS] ‚úÖ Cl√©s LLM r√©cup√©r√©es avec succ√®s`);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          addDebugLog(`[${new Date().toLocaleTimeString()}] [WARNING] ‚ö†Ô∏è Erreur lors de la r√©cup√©ration des cl√©s LLM: ${errorMessage}`);
          // Don't fail initialization if LLM keys can't be fetched
        }
        
        // Step 6: Final loading delay
        setInitStage('final_loading');
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] ‚è≥ √âtape 6/6: D√©lai de chargement final`);
        await new Promise(resolve => setTimeout(resolve, 2000));

        if (!mounted) return;

        setInitStage('completed');
        addDebugLog(`[${new Date().toLocaleTimeString()}] [SUCCESS] ‚úÖ Initialisation termin√©e avec succ√®s !`);
        addMessage({ type: 'agent_response', content: translations.agentReady });
        
        // Log final state summary
        const finalState = useStore.getState();
        const llmKeysState = useLLMKeysStore.getState();
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üìä √âtat final:`);
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] - Session ID: ${finalState.sessionId ? 'PR√âSENT' : 'ABSENT'}`);
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] - Auth Token: ${finalState.authToken ? 'PR√âSENT' : 'ABSENT'}`);
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] - Server Healthy: ${finalState.serverHealthy ? 'OUI' : 'NON'}`);
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] - Messages Count: ${finalState.messages.length}`);
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] - LLM Keys Count: ${llmKeysState.keys.length}`);
        addDebugLog(`[${new Date().toLocaleTimeString()}] [VERBOSE] üöÄ === FIN INITIALISATION COMPL√àTE ===`);
        
        if (initError) {
          addMessage({
            type: 'error',
            content: `‚ö†Ô∏è INITIALISATION TERMIN√âE AVEC ERREURS\n\n‚ùå Erreur: ${initError}\n\nüîç √âtape finale: ${initStage}\n\nüí° L'application peut ne pas fonctionner correctement.`
          });
        }
        
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error('üö® Initialization error:', error);
        setInitError(`Erreur critique d'initialisation: ${errorMessage}`);
        setInitStage('failed');
        
        addDebugLog(`[${new Date().toLocaleTimeString()}] [ERROR] üö® ERREUR CRITIQUE: ${errorMessage}`);
        addDebugLog(`[${new Date().toLocaleTimeString()}] [ERROR] üìç √âtape qui a √©chou√©: ${initStage}`);
        addDebugLog(`[${new Date().toLocaleTimeString()}] [ERROR] üîç Stack trace: ${error instanceof Error ? error.stack : 'Non disponible'}`);
        
        addMessage({
          type: 'error',
          content: `üö® ERREUR CRITIQUE D'INITIALISATION\n\n‚ùå ${errorMessage}\n\nüîç √âtape qui a √©chou√©: ${initStage}\n\nüìã Informations de d√©bogage:\n- URL: ${window.location.href}\n- Timestamp: ${new Date().toISOString()}\n- User Agent: ${navigator.userAgent.substring(0, 100)}...\n\nüí° Actions recommand√©es:\n1. Rechargez la page (F5)\n2. V√©rifiez la console du navigateur\n3. V√©rifiez que le serveur backend fonctionne\n4. Contactez le support si le probl√®me persiste`
        });
      }
    };

    initialize();
    
    return () => {
      mounted = false;
    };
  }, [addDebugLog, addMessage, checkServerHealth, initializeAuthToken, initializeSession, fetchKeys, translations.agentReady, translations.interfaceInitialized, initError, initStage]);

  // Debug display component (only shows if there are critical errors)
  if (initError && initStage === 'failed') {
    return (
      <div style={{
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.9)',
        color: 'white',
        padding: '20px',
        fontFamily: 'monospace',
        fontSize: '14px',
        zIndex: 9999,
        overflow: 'auto'
      }}>
        <h2 style={{ color: '#ff6b6b', marginBottom: '20px' }}>üö® ERREUR CRITIQUE D'INITIALISATION</h2>
        <div style={{ marginBottom: '15px' }}>
          <strong>‚ùå Erreur:</strong> {initError}
        </div>
        <div style={{ marginBottom: '15px' }}>
          <strong>üìç √âtape:</strong> {initStage}
        </div>
        <div style={{ marginBottom: '15px' }}>
          <strong>üï∞Ô∏è Timestamp:</strong> {new Date().toISOString()}
        </div>
        <div style={{ marginBottom: '15px' }}>
          <strong>üåê URL:</strong> {window.location.href}
        </div>
        {Object.keys(debugInfo).length > 0 && (
          <details style={{ marginBottom: '15px' }}>
            <summary style={{ cursor: 'pointer', color: '#ffd93d' }}>üîç Informations de d√©bogage</summary>
            <pre style={{ marginTop: '10px', background: 'rgba(255, 255, 255, 0.1)', padding: '10px', borderRadius: '4px', overflow: 'auto' }}>
              {JSON.stringify(debugInfo, null, 2)}
            </pre>
          </details>
        )}
        <div style={{ marginTop: '20px' }}>
          <button 
            onClick={() => window.location.reload()} 
            style={{
              padding: '10px 20px',
              backgroundColor: '#4dabf7',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
              marginRight: '10px'
            }}
          >
            üîÑ Recharger la page
          </button>
          <button 
            onClick={() => {
              localStorage.clear();
              sessionStorage.clear();
              window.location.reload();
            }} 
            style={{
              padding: '10px 20px',
              backgroundColor: '#ff8787',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer'
            }}
          >
            üóëÔ∏è Vider le cache et recharger
          </button>
        </div>
      </div>
    );
  }
  
  return null; // This component doesn't render anything visible in normal operation
};
