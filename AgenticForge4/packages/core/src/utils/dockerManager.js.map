{"version":3,"file":"dockerManager.js","sourceRoot":"","sources":["dockerManager.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * src/utils/dockerManager.ts\n *\n * Fournit des fonctions pour exécuter du code dans des conteneurs Docker sécurisés (sandbox).\n */\n\nimport Docker from 'dockerode';\n\nimport { config } from '../config.js';\nimport logger from '../logger.js';\nimport { UserError } from './errorUtils.js';\n\nconst docker = new Docker(); // Se connecte au socket Docker local par défaut\n\n// Définition manuelle du type Mount car il n'est pas exporté par @types/dockerode\ninterface DockerMount {\n  ReadOnly?: boolean;\n  Source: string;\n  Target: string;\n  Type: 'bind' | 'tmpfs' | 'volume';\n}\n\ninterface ExecutionResult {\n  exitCode: number;\n  stderr: string;\n  stdout: string;\n}\n\ninterface SandboxOptions {\n  mounts?: DockerMount[];\n  workingDir?: string;\n}\n\n/**\n * Exécute une commande dans un conteneur Docker jetable.\n * @param imageName - L'image Docker à utiliser.\n * @param command - La commande à exécuter.\n * @param options - Options supplémentaires pour le sandbox (workingDir, mounts).\n * @returns Une promesse qui se résout avec le résultat de l'exécution.\n */\nexport async function runInSandbox(\n  imageName: string,\n  command: string[],\n  options: SandboxOptions = {},\n): Promise<ExecutionResult> {\n  const log = logger.child({ imageName, module: 'DockerManager' });\n  log.info({ command, options }, 'Starting sandboxed execution');\n\n  let container: Docker.Container | null = null;\n  try {\n    await pullImageIfNotExists(imageName);\n\n    container = await docker.createContainer({\n      Cmd: command,\n      HostConfig: {\n        CpuShares: 512,\n        Memory: parseMemoryString(config.CONTAINER_MEMORY_LIMIT),\n        Mounts: options.mounts,\n        NetworkMode: 'bridge',\n      },\n      Image: imageName,\n      Tty: false,\n      WorkingDir: options.workingDir,\n    });\n\n    await container.start();\n\n    const waitPromise = container.wait();\n    const timeoutPromise = new Promise((_, reject) =>\n      setTimeout(\n        () => reject(new UserError('Execution timed out')),\n        config.CODE_EXECUTION_TIMEOUT_MS,\n      ),\n    );\n\n    const result = (await Promise.race([waitPromise, timeoutPromise])) as {\n      StatusCode: number;\n    };\n\n    const logStream = await container.logs({\n      follow: false,\n      stderr: true,\n      stdout: true,\n    });\n\n    const { stderr, stdout } = demuxStream(logStream as Buffer);\n\n    log.info(\n      { exitCode: result.StatusCode, stderr, stdout },\n      'Sandboxed execution finished',\n    );\n\n    return {\n      exitCode: result.StatusCode,\n      stderr: stderr,\n      stdout: stdout,\n    };\n  } catch (error) {\n    log.error({ err: error }, 'Error during sandboxed execution');\n    throw error;\n  } finally {\n    if (container) {\n      await container.remove({ force: true });\n      log.debug('Sandbox container removed.');\n    }\n  }\n}\n\n/**\n * Démultiplexe le flux de logs de Docker en stdout et stderr.\n */\nfunction demuxStream(stream: Buffer): { stderr: string; stdout: string } {\n  let stdout = '';\n  let stderr = '';\n  let offset = 0;\n\n  while (offset < stream.length) {\n    const type = stream[offset];\n    const length = stream.readUInt32BE(offset + 4);\n    offset += 8;\n    const payload = stream.toString('utf-8', offset, offset + length);\n    if (type === 1) {\n      stdout += payload;\n    } else if (type === 2) {\n      stderr += payload;\n    }\n    offset += length;\n  }\n  return { stderr, stdout };\n}\n\n/**\n * Analyse une chaîne de caractères représentant une taille de mémoire (ex: \"2g\", \"512m\")\n * et la convertit en octets.\n * @param memoryString - La chaîne de caractères à analyser.\n * @returns Le nombre d'octets.\n */\nfunction parseMemoryString(memoryString: string): number {\n  const unit = memoryString.slice(-1).toLowerCase();\n  const value = parseInt(memoryString.slice(0, -1), 10);\n\n  if (isNaN(value)) {\n    throw new Error(`Invalid memory string: ${memoryString}`);\n  }\n\n  switch (unit) {\n    case 'g':\n      return value * 1024 * 1024 * 1024;\n    case 'k':\n      return value * 1024;\n    case 'm':\n      return value * 1024 * 1024;\n    default:\n      return parseInt(memoryString, 10);\n  }\n}\n\n/**\n * Tire une image Docker si elle n'est pas déjà présente localement.\n */\nasync function pullImageIfNotExists(imageName: string): Promise<void> {\n  try {\n    await docker.getImage(imageName).inspect();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (error: any) {\n    if (error?.statusCode === 404) {\n      logger.info(`Image ${imageName} not found locally, pulling...`);\n      const stream = await docker.pull(imageName);\n      await new Promise((resolve, reject) => {\n        docker.modem.followProgress(stream, (err, res) =>\n          err ? reject(err) : resolve(res),\n        );\n      });\n      logger.info(`Image ${imageName} pulled successfully.`);\n    } else {\n      throw error;\n    }\n  }\n}\n"]}