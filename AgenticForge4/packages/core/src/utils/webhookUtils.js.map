{"version":3,"file":"webhookUtils.js","sourceRoot":"","sources":["webhookUtils.ts"],"names":[],"mappings":"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","sourcesContent":["// src/utils/webhookUtils.ts (Corrigé pour SessionData)\n\nimport crypto from 'crypto';\n\n\nimport type { TaskOutcome } from './asyncToolHelper.js';\nimport type { ErrorDetails } from './errorUtils.js';\n\nimport { config } from '../config.js';\nimport logger from '../logger.js';\nimport { WEBHOOK_SIGNATURE_HEADER } from './constants.js';\nimport { getErrDetails, WebhookError } from './errorUtils.js';\n\n/**\n * Envoie un webhook à l'URL spécifiée avec le payload.\n */\nexport async function sendWebhook<P, R>(\n  url: string,\n  payload: TaskOutcome<P, R>,\n  taskId: string,\n  toolName: string,\n  throwErr = false,\n): Promise<boolean> {\n  const log = logger.child({\n    cbUrl: url,\n    op: 'sendWebhook',\n    taskId,\n    tool: toolName,\n  });\n  try {\n    const signature = generateSignature(payload);\n    log.info(\n      { payloadSize: JSON.stringify(payload).length },\n      'Envoi du webhook avec signature...',\n    );\n    const res = await fetch(url, {\n      body: JSON.stringify(payload),\n      headers: {\n        'Content-Type': 'application/json',\n        'User-Agent': `FastMCP/${toolName}-Callback-Agent/1.1`,\n        [WEBHOOK_SIGNATURE_HEADER]: signature,\n        'X-Task-ID': taskId,\n      },\n      method: 'POST',\n      signal: AbortSignal.timeout(15000),\n    });\n    if (!res.ok) {\n      const errBody = await res\n        .text()\n        .catch(\n          () =>\n            \"Échec de la récupération du corps de la réponse d'erreur du webhook.\",\n        );\n      log.error(\n        { body: errBody, status: res.status, statusText: res.statusText },\n        'Le webhook a échoué avec une réponse non-OK.',\n      );\n      if (throwErr) {\n        throw new WebhookError(\n          `La livraison du webhook à ${url} a échoué. Statut : ${res.status} ${res.statusText}`,\n          { name: 'WebhookDeliveryError', statusCode: res.status, body: errBody, originalPayload: payload },\n        );\n      }\n      return false;\n    }\n\n    log.info({ status: res.status }, 'Webhook envoyé avec succès.');\n    return true;\n  } catch (error: unknown) {\n    const errDetails: ErrorDetails = getErrDetails(error);\n    log.error({ err: errDetails }, \"Erreur lors de l'envoi du webhook.\");\n    if (throwErr) {\n      if (error instanceof WebhookError) throw error;\n      throw new WebhookError(\n        `Erreur d'infrastructure lors de l'envoi du webhook à ${url}: ${errDetails.message}`,\n        { name: 'WebhookInfrastructureError', originalError: errDetails },\n      );\n    }\n    return false;\n  }\n}\n\n/**\n * Utilitaire pour vérifier la signature HMAC.\n */\nexport function verifyWebhookSignature(\n  payload: string,\n  receivedSignature: string,\n  secret: string,\n): boolean {\n  if (!payload || !receivedSignature || !secret) {\n    logger.warn(\n      '[WebhookUtils] Vérification de signature impossible : payload, signature ou secret manquant.',\n    );\n    return false;\n  }\n  try {\n    const hmac = crypto.createHmac('sha256', secret);\n    hmac.update(payload);\n    const computedSignature = hmac.digest('hex');\n    return crypto.timingSafeEqual(\n      Buffer.from(computedSignature, 'hex'),\n      Buffer.from(receivedSignature, 'hex'),\n    );\n  } catch (error) {\n    logger.error(\n      { err: getErrDetails(error) },\n      '[WebhookUtils] Erreur lors de la vérification de la signature du webhook.',\n    );\n    return false;\n  }\n}\n\n/**\n * Génère une signature HMAC SHA256 pour un payload donné.\n */\nfunction generateSignature(payload: unknown): string {\n  const secret = config.WEBHOOK_SECRET;\n  if (!secret) {\n    logger.error(\n      `[WebhookUtils] WEBHOOK_SECRET n'est pas défini. Impossible de signer le webhook.`,\n    );\n    throw new Error(`WEBHOOK_SECRET is not configured. Cannot sign webhook.`);\n  }\n  const hmac = crypto.createHmac('sha256', secret);\n  hmac.update(JSON.stringify(payload));\n  return hmac.digest('hex');\n}\n"]}